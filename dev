#!/bin/bash
# 🚀 远程开发环境管理工具
# 作者: Zhang-Jingdian (2157429750@qq.com)
# 版本: v4.0

set -e

# ================================================================================================
# 颜色和图标定义
# ================================================================================================
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly GRAY='\033[0;90m'
readonly NC='\033[0m'

readonly SUCCESS="✅"
readonly ERROR="❌"
readonly INFO="ℹ️"
readonly DOCKER="🐳"
readonly SYNC="📁"
readonly ROCKET="🚀"
readonly CONFIG="⚙️"
readonly NETWORK="🌐"

# ================================================================================================
# 配置管理
# ================================================================================================
load_config() {
    [[ -f "config.env" ]] || { echo -e "${RED}${ERROR} config.env 文件不存在${NC}"; exit 1; }
    source config.env
}

# ================================================================================================
# 用户界面 - 精简美观的输出
# ================================================================================================
print_header() {
    echo -e "${CYAN}${ROCKET} 远程开发环境管理工具 v4.0${NC}"
    echo -e "${GRAY}────────────────────────────────────────${NC}"
}

print_success() { echo -e "${GREEN}${SUCCESS} $1${NC}"; }
print_error() { echo -e "${RED}${ERROR} $1${NC}"; }
print_info() { echo -e "${BLUE}${INFO} $1${NC}"; }
print_docker() { echo -e "${CYAN}${DOCKER} $1${NC}"; }
print_sync() { echo -e "${YELLOW}${SYNC} $1${NC}"; }

show_help() {
    print_header
    echo
    echo -e "${YELLOW}用法:${NC} ./dev <command> [options]"
    echo
    echo -e "${YELLOW}核心命令:${NC}"
    echo "  setup       初始化环境"
    echo "  sync        同步文件到远程"
    echo "  up          启动Docker容器"
    echo "  down        停止Docker容器"
    echo "  status      查看运行状态"
    echo "  logs        查看实时日志"
    echo "  remote-run  在远程容器执行命令"
    echo
    echo -e "${YELLOW}开发命令:${NC}"
    echo "  watch       监控文件变化并自动同步"
    echo "  web         启动Web管理界面"
    echo "  test        运行系统测试"
    echo
    echo -e "${YELLOW}示例:${NC}"
    echo "  ./dev up                    # 启动环境"
    echo "  ./dev remote-run bash       # 进入交互式shell"
    echo "  ./dev remote-run 'ls -la'   # 执行命令"
    echo
}

# ================================================================================================
# 核心功能 - 优化算法和数据结构
# ================================================================================================

# 文件同步 - 优化同步策略
sync_files() {
    print_sync "同步文件到远程..."
    load_config
    
    local local_path=${LOCAL_PATH:-"."}
    local remote_path=${REMOTE_PATH:-"/tmp/workspace"}
    local remote_host=${REMOTE_HOST:-"localhost"}
    
    # 优化的排除模式 - 减少不必要的文件传输
    local exclude_patterns=(
        '.git' 'node_modules' '__pycache__' '.venv' 
        'dist' '*.pyc' '*.log' '.DS_Store' 
        '*.tmp' '.pytest_cache' 'coverage'
    )
    
    local rsync_excludes=""
    for pattern in "${exclude_patterns[@]}"; do
        rsync_excludes="$rsync_excludes --exclude='$pattern'"
    done
    
    if eval rsync -av $rsync_excludes "./" "$remote_host:$remote_path/"; then
        print_success "文件同步完成"
    else
        print_error "文件同步失败"
        exit 1
    fi
}

# Docker容器管理 - 精简的容器操作
docker_up() {
    print_docker "启动Docker容器..."
    if docker-compose -f docker/docker-compose.yml up -d; then
        print_success "Docker容器启动成功"
        echo -e "${GRAY}端口映射: 8080(Web) 9000(API)${NC}"
    else
        print_error "Docker容器启动失败"
        exit 1
    fi
}

docker_down() {
    print_docker "停止Docker容器..."
    if docker-compose -f docker/docker-compose.yml down; then
        print_success "Docker容器停止成功"
    else
        print_error "Docker容器停止失败"
        exit 1
    fi
}

# 状态检查 - 优化状态显示
show_status() {
    print_header
    echo
    
    # Docker状态检查
    local docker_status=$(docker-compose -f docker/docker-compose.yml ps 2>/dev/null || echo "")
    if echo "$docker_status" | grep -q "Up"; then
        print_docker "容器运行中"
        echo "$docker_status" | grep -E "(NAME|remote-dev-env)" | sed 's/^/  /'
    else
        echo -e "${RED}${DOCKER} 容器未运行${NC}"
        local containers=$(docker ps -a --filter "name=remote-dev-env" --format "table {{.Names}}\t{{.Status}}" 2>/dev/null | grep -v NAMES)
        [[ -n "$containers" ]] && echo "$containers" | sed 's/^/  /'
    fi
    
    echo
    
    # 配置状态
    if [[ -f "config.env" ]]; then
        print_success "配置文件已加载"
        load_config
        echo -e "  ${GRAY}本地路径:${NC} ${LOCAL_PATH:-'.'}"
        echo -e "  ${GRAY}远程主机:${NC} ${REMOTE_HOST:-'localhost'}"
        echo -e "  ${GRAY}远程路径:${NC} ${REMOTE_PATH:-'/tmp/workspace'}"
    else
        print_error "配置文件不存在"
    fi
    
    echo
    
    # 网络连通性检查（快速）
    if ping -c 1 "${REMOTE_HOST:-localhost}" >/dev/null 2>&1; then
        print_success "网络连接正常"
    else
        echo -e "${RED}${NETWORK} 网络连接失败${NC}"
    fi
}

# 日志查看 - 简化日志输出
show_logs() {
    print_info "显示Docker容器日志 (Ctrl+C 退出)..."
    docker-compose -f docker/docker-compose.yml logs -f
}

# 远程命令执行 - 优化交互体验
remote_run() {
    local command="$1"
    
    load_config
    local remote_host=${REMOTE_HOST:-"localhost"}
    local remote_path=${REMOTE_PATH:-"/tmp/workspace"}
    local container_name="remote-dev-env"
    
    if [[ -z "$command" ]]; then
        command="bash"
        print_info "启动交互式shell..."
    fi
    
    print_info "连接到 $remote_host 执行: $command"
    
    # 先同步最新代码
    sync_files
    
    if [[ "$command" == "bash" || "$command" == "sh" ]]; then
        # 交互式shell配置
        local bashrc_file=".remote_bashrc_simple"  # 默认使用简化版
        
        if [[ -t 0 ]]; then
            echo -e "${YELLOW}选择提示符样式: [1] 完整版 [2] 简化版 (默认: 2)${NC}"
            read -t 3 -p "请选择: " prompt_choice
            [[ "$prompt_choice" == "1" ]] && bashrc_file=".remote_bashrc"
        fi
        
        local interactive_command="cd $remote_path && docker exec -it $container_name bash -c \"
if [ -f /workspace/docker/$bashrc_file ]; then
    cp /workspace/docker/$bashrc_file /root/.bashrc
fi
cd /workspace
bash --login
\""
        ssh -t "$remote_host" "$interactive_command"
    else
        # 非交互式命令
        local remote_command="cd $remote_path && docker exec -i $container_name $command"
        ssh "$remote_host" "$remote_command"
    fi
}

# 环境初始化 - 优化安装检查
setup_env() {
    print_header
    print_info "检查系统依赖..."
    
    # 依赖检查数组
    local dependencies=("docker" "docker-compose" "rsync" "ssh")
    local missing_deps=()
    
    for dep in "${dependencies[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing_deps+=("$dep")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        print_error "缺少依赖: ${missing_deps[*]}"
        exit 1
    fi
    
    print_success "所有依赖已安装"
    
    # 配置文件检查
    if [[ ! -f "config.env" ]]; then
        print_info "创建默认配置文件..."
        cat > config.env << 'EOF'
# 远程服务器配置
REMOTE_HOST=192.168.0.105
REMOTE_USER=zjd
REMOTE_PATH=/home/zjd/workspace

# 本地配置
LOCAL_PATH=./work

# 同步配置
SYNC_EXCLUDE=".git,node_modules,*.log,*.tmp,.DS_Store,__pycache__"
EOF
        print_success "配置文件已创建: config.env"
    fi
    
    print_success "环境初始化完成"
}

# 文件监控 - 优化监控算法
watch_files() {
    print_info "启动文件监控..."
    
    if ! command -v fswatch >/dev/null 2>&1; then
        print_error "需要安装 fswatch: brew install fswatch"
        exit 1
    fi
    
    local watch_path=${LOCAL_PATH:-"."}
    print_info "监控目录: $watch_path"
    
    fswatch -o "$watch_path" --exclude="\.git" --exclude="node_modules" --exclude="__pycache__" | while read -r
    do
        echo -e "${YELLOW}$(date '+%H:%M:%S')${NC} 检测到文件变化，正在同步..."
        sync_files
    done
}

# Web界面启动
start_web() {
    print_info "启动Web管理界面..."
    
    # 启动后端API
    if [[ -f "main.py" ]]; then
        print_info "启动后端API服务 (端口 9000)..."
        python3 main.py &
        local api_pid=$!
    fi
    
    # 启动前端开发服务器
    if [[ -d "web" ]]; then
        print_info "启动前端开发服务器 (端口 3000)..."
        cd web && npm run dev &
        local web_pid=$!
        cd ..
    fi
    
    print_success "Web界面已启动"
    echo -e "${GRAY}API: http://localhost:9000${NC}"
    echo -e "${GRAY}Web: http://localhost:3000${NC}"
    echo -e "${YELLOW}按 Ctrl+C 停止服务${NC}"
    
    # 等待用户中断
    trap 'kill $api_pid $web_pid 2>/dev/null; print_info "服务已停止"; exit 0' INT
    wait
}

# 系统测试
run_tests() {
    print_info "运行系统测试..."
    
    # 基础连通性测试
    if [[ -f "config.env" ]]; then
        load_config
        if ping -c 1 "$REMOTE_HOST" >/dev/null 2>&1; then
            print_success "网络连通性测试通过"
        else
            print_error "网络连通性测试失败"
            return 1
        fi
    fi
    
    # Docker测试
    if docker --version >/dev/null 2>&1; then
        print_success "Docker测试通过"
    else
        print_error "Docker测试失败"
        return 1
    fi
    
    print_success "所有测试通过"
}

# ================================================================================================
# 主程序入口 - 优化命令路由
# ================================================================================================
main() {
    case "${1:-help}" in
        setup)      setup_env ;;
        sync)       sync_files ;;
        watch)      watch_files ;;
        up)         docker_up ;;
        down)       docker_down ;;
        status)     show_status ;;
        logs)       show_logs ;;
        remote-run) remote_run "$2" ;;
        web)        start_web ;;
        test)       run_tests ;;
        help|*)     show_help ;;
    esac
}

# 执行主程序
main "$@" 